# -*- coding: utf-8 -*-
"""HopeSimulation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UAy2IV2aQ_njfexPVVVHxhKDt2wBty_1
"""

#import

import random
import matplotlib.pyplot as plt

#mutate
#neighbour function
def mutate(individual, rate=0.1):
    if random.random() < rate:
        return individual + random.randint(-1, 1)
    else:
        return individual

#reproduce
def repro(p1, p2):
    c1=random.randint(min(p1,p2),max(p1,p2))
    c2=random.randint(min(p1,p2),max(p1,p2))
    return c1,c2

def fruit_comp(population, num_fruits):
    """
    RULES:
    - Maximum 2 people can share a fruit
    - If difference < 2: split fruit (each gets 0.5)
    - If difference >= 2: HIGHER value wins
    - Max capacity: value/3
    """
    fruits_available = list(range(1, num_fruits + 1))
    fruit_amounts = [0] * len(population)
    fruit_occupancy = {fruit: [] for fruit in fruits_available}
    hungry_indices = list(range(len(population)))

    while fruits_available and hungry_indices:
        choices = {}

        for idx in hungry_indices:
            ind_value = population[idx]
            max_capacity = ind_value / 3

            if fruit_amounts[idx] >= max_capacity:
                continue

            available_fruits = [f for f in fruits_available if len(fruit_occupancy[f]) < 2]

            if not available_fruits:
                break

            chosen = random.choice(available_fruits)
            if chosen not in choices:
                choices[chosen] = []
            choices[chosen].append(idx)

        if not choices:
            break

        newly_fed = []
        fruits_to_remove = []

        for fruit, indices in choices.items():
            for idx in indices:
                if len(fruit_occupancy[fruit]) < 2:
                    fruit_occupancy[fruit].append(idx)
                    newly_fed.append(idx)

            if len(fruit_occupancy[fruit]) >= 2:
                idx1, idx2 = fruit_occupancy[fruit][0], fruit_occupancy[fruit][1]
                ind1, ind2 = population[idx1], population[idx2]

                diff = abs(ind1 - ind2)

                if diff < 2:
                    # Split the fruit
                    max_cap1 = ind1 / 3
                    max_cap2 = ind2 / 3

                    if fruit_amounts[idx1] + 0.5 <= max_cap1:
                        fruit_amounts[idx1] += 0.5
                    if fruit_amounts[idx2] + 0.5 <= max_cap2:
                        fruit_amounts[idx2] += 0.5
                else:
                    # Higher value wins
                    winner_idx = idx1 if ind1 > ind2 else idx2
                    winner_value = population[winner_idx]
                    max_cap_winner = winner_value / 3

                    if fruit_amounts[winner_idx] + 1.0 <= max_cap_winner:
                        fruit_amounts[winner_idx] += 1.0

                fruits_to_remove.append(fruit)

        for fruit in fruits_to_remove:
            fruits_available.remove(fruit)

        # Update hungry population
        hungry_indices_new = []
        for idx in hungry_indices:
            ind_value = population[idx]
            max_capacity = ind_value / 3

            if fruit_amounts[idx] < max_capacity:
                hungry_indices_new.append(idx)

        hungry_indices = hungry_indices_new

        if not newly_fed:
            break

    # Distribute remaining fruits that have 1 person
    for fruit in fruits_available:
        if len(fruit_occupancy[fruit]) == 1:
            idx = fruit_occupancy[fruit][0]
            ind_value = population[idx]
            max_capacity = ind_value / 3

            if fruit_amounts[idx] + 1.0 <= max_capacity:
                fruit_amounts[idx] += 1.0

    return fruit_amounts

def evolve(pop_size=20, generations=100, num_fruits=20):
    population = [random.randint(0, 20) for _ in range(pop_size)]
    avg_values = []
    pop_sizes = []

    for gen in range(generations):
        fruit_amounts = fruit_comp(population, num_fruits)

        # Track average value
        avg_value = sum(population) / len(population)
        avg_values.append(avg_value)

        # NEW: Survival based on value/10
        survivors = []
        survivor_indices = []
        for idx, ind in enumerate(population):
            fruits = fruit_amounts[idx]
            survival_threshold = ind / 10  # Survival cost

            if fruits == 0:
                # 0 fruits â†’ die
                pass
            elif fruits >= survival_threshold:
                # Enough fruits to survive
                survivors.append(ind)
                survivor_indices.append(idx)
            else:  # 0 < fruits < survival_threshold
                # Probabilistic survival
                survival_chance = fruits / survival_threshold
                if random.random() < survival_chance:
                    survivors.append(ind)
                    survivor_indices.append(idx)

        if len(survivors) == 0:
            print(f"Gen {gen}: EXTINCTION - No survivors!")
            break

        # NEW: Reproduction based on value/3
        reproducers = []
        for idx in survivor_indices:
            ind = population[idx]
            fruits = fruit_amounts[idx]
            reproduction_threshold = ind / 3  # NEW: Changed from fixed 5 to value/3

            if fruits >= reproduction_threshold:
                # Enough fruits to reproduce
                reproducers.append(ind)
            else:
                # Probabilistic reproduction
                reproduction_chance = fruits / reproduction_threshold
                if random.random() < reproduction_chance:
                    reproducers.append(ind)

        # Create next generation with survivors
        next_gen = []

        # Reproducers create offspring
        if len(reproducers) >= 2:
            random.shuffle(reproducers)
            for i in range(0, len(reproducers) - 1, 2):
                p1 = reproducers[i]
                p2 = reproducers[i + 1]
                c1, c2 = repro(p1, p2)
                c1 = mutate(c1)
                c2 = mutate(c2)
                next_gen.extend([c1, c2])

            if len(reproducers) % 2 == 1:
                last = reproducers[-1]
                child = mutate(last)
                next_gen.append(child)
        elif len(reproducers) == 1:
            child = mutate(reproducers[0])
            next_gen.append(child)

        population = next_gen
        pop_sizes.append(len(population))

        print(f"Gen {gen}: Pop={len(population)}, Survivors={len(survivors)}, "
              f"Reproducers={len(reproducers)}, Avg Value={avg_value:.2f}")

        if len(population) == 0:
            print("EXTINCTION!")
            break

    # Plot results
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))

    # Average population value over time
    ax1.plot(range(len(avg_values)), avg_values, '-', color='blue')
    ax1.set_xlabel('Generation')
    ax1.set_ylabel('Average Individual Value')
    ax1.set_title('Evolution of Average Value')
    ax1.grid(True, alpha=0.3)

    # Population size over time
    ax2.plot(range(len(pop_sizes)), pop_sizes, '-', color='green')
    ax2.set_xlabel('Generation')
    ax2.set_ylabel('Population Size')
    ax2.set_title('Population Size Over Time')
    ax2.set_ylim(bottom=0)
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

evolve(pop_size=20, generations=200, num_fruits=20)